---
title: 提示词工程
description: 介绍大语言模型的提示词工程。
---

import ExampleBlock from '../../components/ExampleBlock'
import { Callout } from 'nextra/components'

# 5. 大语言模型提示词工程

在使用大语言模型时，提示词（Prompt）起着至关重要的作用。通过精心设计提示词，你可以大大提高模型的输出质量和准确性。接下来，我们将详细介绍为什么要使用提示词、如何通过不同提示词改变输出结果，并分享一些常用的提示词技巧。

## 1. **为什么要使用提示词？**

大语言模型生成的内容是基于你输入的提示词。通过调整提示词的表达方式，你可以控制模型生成的内容，包括语气、风格、长度、细节等。简单来说，提示词就像是向模型发出指令，指导它如何理解问题并产生相应的答案。

**示例**：

如果你只是简单地输入

> 写一篇关于人工智能的文章

模型生成的内容可能会非常普通，缺乏深度。如果你在提示词中加入更多的细节和要求，例如：

> 请写一篇关于人工智能的文章，重点讨论其在医疗行业的应用，并简要提及挑战和未来发展

模型将能生成更加符合你需求的高质量内容。

根据提示词的不同，模型的输出可能会有很大的差异。以下是几个常见的提示词设置对比：

<Callout type="info" emoji="💡">
这些是关于如何通过调整提示词来影响模型输出的示例。
</Callout>

### 示例对比：普通提示词 vs. 详细提示词

<ExampleBlock
  question="**普通提示词**：请写一篇关于人工智能的文章。"
  answer="**模型输出**：大语言模型可能生成一篇普通的文章，内容比较笼统，可能涵盖了人工智能的基本定义，但不会深入讨论具体应用。"
/>

<ExampleBlock
  question="**详细提示词**：请写一篇关于人工智能的文章，重点讨论人工智能在医疗行业中的应用，简要提及相关的挑战与未来发展方向。"
  answer="**模型输出**：模型会生成更为详细的内容，专注于人工智能在医疗行业的应用，提到相关的技术，如疾病诊断、个性化治疗，并且讨论人工智能面临的挑战（如数据隐私问题）及未来发展（如智能医疗设备的普及）。"
/>

### 示例对比：简洁指令 vs. 引导性问题

<ExampleBlock
  question="**简洁指令**：给我一个关于环保的报告。"
  answer="**模型输出**：模型生成的报告可能会是一般性的，包含一些环保的基础概念，但内容没有明确的方向或细节。"
/>

<ExampleBlock
  question="**引导性问题**：请给我一个关于环保的报告，聚焦在减少碳排放和提高能源效率的实际措施，结合全球和中国的现状。"
  answer="**模型输出**：模型会更有针对性，生成的报告会具体讨论碳排放减少的措施（如清洁能源技术）以及提高能源效率的实际案例，同时结合全球和中国的具体情况。"
/>

<Callout type="info" emoji="💡">
有个小知识点，因为有分词的原因，所以在与大语言模型进行对话的时候，尽量使用正向的语句，不要使用负面语句
</Callout>

### 思考类大型语言模型与一般大型语言模型的区别

近年来，随着研究的深入，出现了一些被认为是“思考类”或“推理增强型”的大型语言模型（例如 DeepSeek R1、OpenAI 的 o系列模型等）。这些模型与“一般”的大型语言模型在设计、训练或应用方式上存在一些关键区别，使得它们在处理需要复杂推理、规划或逻辑思维的任务时表现更出色。

**一般大型语言模型：**

*   **主要目标：** 学习语言的统计规律，生成流畅、连贯、语法正确的文本。它们擅长基于训练数据中的模式进行预测和生成。
*   **训练数据：** 大量的文本和代码数据，学习词汇、语法、语义、常识等。
*   **推理能力：** 主要依赖于在训练数据中学习到的模式和关联。对于需要多步、复杂或抽象推理的任务，可能表现不佳，容易出现逻辑错误或“幻觉”。
*   **应用：** 文本生成、摘要、翻译、问答（基于检索或简单模式匹配）。

**思考类大型语言模型（或推理增强型模型）：**

*   **主要目标：** 除了生成流畅的文本外，更注重提升模型的推理、规划和问题解决能力。
*   **训练或设计方式：**
    *   **专门的训练数据：** 可能在包含更多推理任务、逻辑谜题、数学问题或代码的复杂数据集上进行训练。
    *   **模型架构改进：** 可能采用更适合推理任务的模型架构或注意力机制。
    *   **结合外部工具：** 有些模型可以与外部工具（如计算器、搜索引擎、代码解释器）结合，利用这些工具进行辅助推理和计算。
    *   **强化学习或人类反馈：** 可能通过强化学习或人类反馈来优化模型在推理任务上的表现。
    *   **提示词工程的集成：** 一些模型可能在内部集成了 CoT 或 ToT 等提示词工程技术，使其能够自动进行多步推理。
*   **推理能力：** 能够更好地进行多步逻辑推理、数学计算、规划和问题解决。能够生成更可靠、更准确的推理过程。
*   **应用：** 复杂问答、代码生成和调试、数学问题求解、逻辑推理、规划任务、科学研究辅助等。

## 3 **常用的提示词技巧**

为了更好地利用大语言模型，我们可以运用以下几种提示词技巧来优化输出结果。

### 3.1 **设定输出风格或语气**

💡 **关键：** 明确告诉模型你想要的“感觉”。

**怎么做：** 在提示词中指定如“正式”、“轻松”、“幽默”、“专业”等语气。

#### 示例：**语气控制**

<ExampleBlock
  question="请写一封感谢信，语气要正式。"
  answer="**尊敬的XXX，感谢您在过去的工作中提供的宝贵支持。您的贡献对我们团队至关重要，我深感荣幸能与您合作。"
/>

<ExampleBlock
  question="请写一封感谢信，语气要轻松幽默。"
  answer="嘿，XXX！我真的得感谢你帮我完成了那个任务，你简直就是我的超级英雄！没有你，我可能还在抓狂呢！"
/>

<Callout type="info" emoji="🗣️">
**技巧提示：** 尝试用不同的形容词来描述你想要的语气，例如“专业”、“友好”、“简洁”、“详细”等。
</Callout>

### 3.2 **限定输出的长度**

💡 **关键：** 精准控制模型回答的体量。

**怎么做：** 要求限制字数、句子数或段落数。

#### 示例：**控制长度**

<ExampleBlock
  question="请总结一下这篇文章的主要内容，字数控制在100字以内。"
  answer="文章讨论了人工智能的基本概念、应用领域以及面临的挑战，尤其是在医疗、教育和交通行业的应用前景。未来，人工智能将继续深刻改变各行各业。"
/>

<ExampleBlock
  question="请总结一下这篇文章的主要内容，保持内容精炼，限制在一个段落内。"
  answer="文章介绍了人工智能的关键技术及其应用，强调了在医疗和交通领域的广泛应用，并指出了数据隐私和伦理问题是其发展的主要障碍。"
/>

<Callout type="info" emoji="📏">
**技巧提示：** 除了字数和段落数，你还可以要求模型生成特定数量的项目符号列表或句子。
</Callout>

### 3.3 **使用具体的指令或要求**

💡 **关键：** 让模型的任务更明确。

**怎么做：** 清晰列出你需要包含的要素或需要完成的具体动作。

#### 示例：**具体要求**

<ExampleBlock
  question="请为我生成一个关于环保的演讲稿，要求包括以下几个方面：环保的重要性、政府的作用、个人能做的贡献。"
  answer="各位领导，环保是当今世界最重要的话题之一，保护环境就是保护我们自己。政府应加强环保法规的执行，而我们每个人也可以通过减少能源消耗、减少废物产生等行为，为地球贡献自己的力量。"
/>

<ExampleBlock
  question="请为我生成一个关于环保的演讲稿，要求重点强调个人对环保的贡献，以及如何通过日常习惯改善环境。"
  answer="各位朋友，环保不仅仅是政府的责任，我们每个人的日常行为对环境有着深远影响。从减少塑料使用到节约能源，我们可以从身边的小事做起，共同改善地球的未来。"
/>

<Callout type="info" emoji="🎯">
**技巧提示：** 把你的要求分解成清晰的点或步骤，让模型更容易理解。
</Callout>

### 3.4 **加入上下文**

💡 **关键：** 为模型提供背景，让它更理解你的需求。

**怎么做：** 在提示词中补充相关信息或细节。

#### 示例：**提供上下文信息**

<ExampleBlock
  question="请帮我总结以下内容，内容包括了关于电动汽车的优势和挑战。"
  answer="电动汽车的优势包括减少环境污染、降低能源消耗以及减少噪音污染。然而，其面临的挑战包括高昂的购车成本、充电基础设施的不足和电池寿命的问题。"
/>
<ExampleBlock
  question="请帮我总结以下内容，内容包括了关于电动汽车的优势和挑战。特别要提到在这方面的政策支持和市场反应。"
  answer="电动汽车的优势包括减少碳排放、降低空气污染，尤其在政策支持下，电动汽车市场逐渐扩展。然而，挑战依旧存在，如充电桩数量不足、消费者对续航的担忧等问题仍然需要解决。"
/>
<Callout type="info" emoji="📚">
**技巧提示：** 提供相关的背景信息、数据、或者之前对话的内容，可以帮助模型给出更准确和相关的回答。
</Callout>

### 3.5 一次性示例和少量示例

💡 **关键：** “教会”模型你想要的效果。

**是什么：**

*   **一次性示例 (One-shot):** 提供 **一个** 输入-输出配对。
*   **少量示例 (Few-shot):** 提供 **几个** (2-5个) 输入-输出配对。

**为什么有效：** 利用“上下文学习”，模型无需额外微调，就能从示例中学习任务意图、输出格式和特定风格。

下面我们将通过具体的例子来说明使用一次性示例和少量示例的好处。

#### 一次性示例 (One-shot Prompting)

**好处：**

-   **快速引导模型理解任务：** 即使只提供一个示例，模型也能快速捕捉到任务的核心要求和输出格式。
-   **适用于简单或常见的任务：** 对于模型已经有一定了解的任务类型，一个示例通常足以让模型理解你的意图。
-   **节省提示词空间：** 相比少量示例，一次性示例占用的提示词空间更少，这在处理长文本或有提示词长度限制的情况下很有优势。

**例子：**

假设我们想让模型将一段描述性的文字转换为一个简洁的标题。

**没有示例的提示词：**

```
请为以下描述写一个标题：

描述：这个会议讨论了人工智能在医疗保健领域的最新进展，包括诊断、药物研发和个性化治疗。
```

<Callout type="warning" emoji="⚠️">
**可能的模型输出（可能不够简洁或不够贴合期望）：**

*   人工智能在医疗保健领域的最新进展会议讨论
*   关于人工智能在医疗保健中应用的讨论
</Callout>

**使用一次性示例的提示词：**

```
请为以下描述写一个标题。

示例：
描述：这个产品是一款智能家居设备，可以控制灯光、温度和安全系统。
标题：智能家居控制中心。

描述：这个会议讨论了人工智能在医疗保健领域的最新进展，包括诊断、药物研发和个性化治疗。
标题：
```

<Callout type="success" emoji="✅">
**期望的模型输出（更简洁，符合示例的风格）：**

```
人工智能在医疗保健中的应用进展
```
</Callout>

**解释：** 通过提供一个“描述 -> 标题”的示例，模型理解了我们期望的输出是一个简洁的标题，并且学习了将描述中的关键信息提炼出来。

#### 少量示例 (Few-shot Prompting)

**好处：**

-   **更精确地控制输出格式和风格：** 提供多个示例可以更清晰地展示期望的输出格式、语气、风格或特定的约束条件。
-   **处理更复杂或不常见的任务：** 对于模型不太熟悉或需要更精细控制的任务，少量示例可以提供更全面的指导。
-   **减少歧义：** 当任务可能有多种解释时，多个示例可以帮助模型消除歧义，生成更符合预期的结果。
-   **学习特定的模式或规则：** 如果任务涉及到特定的模式、规则或转换逻辑，少量示例可以帮助模型更好地学习这些模式。

**例子 1：控制输出格式**

假设我们想让模型将一段文本中的关键信息提取出来，并按照特定的 JSON 格式输出。

**没有示例的提示词：**

```
请从以下文本中提取姓名、年龄和职业：

文本：张伟，今年35岁，是一名软件工程师。
```

<Callout type="warning" emoji="⚠️">
**可能的模型输出（可能不是 JSON 格式）：**

*   姓名：张伟
*   年龄：35岁
*   职业：软件工程师
</Callout>

**使用少量示例的提示词：**

```
请从以下文本中提取姓名、年龄和职业，并以 JSON 格式输出。

示例 1：
文本：李华，28岁，是一名教师。
输出：{"姓名": "李华", "年龄": 28, "职业": "教师"}

示例 2：
文本：王芳，42岁，是一名医生。
输出：{"姓名": "王芳", "年龄": 42, "职业": "医生"}

文本：张伟，今年35岁，是一名软件工程师。
输出：
```

<Callout type="success" emoji="✅">
**期望的模型输出（符合 JSON 格式）：**

```json
{"姓名": "张伟", "年龄": 35, "职业": "软件工程师"}
```
</Callout>

**解释：** 通过提供两个示例，模型不仅理解了要提取的信息，还学会了如何将这些信息组织成特定的 JSON 格式。

**例子 2：学习特定的转换规则**

假设我们想让模型将一个日期字符串转换为另一种特定的格式。

**没有示例的提示词：**

```
请将以下日期转换为 YYYY-MM-DD 格式：日期：2023年1月26日
```

<Callout type="warning" emoji="⚠️">
**可能的模型输出（可能不完全符合期望）：**

*   2023-1-26
*   2023/1/26
</Callout>

**使用少量示例的提示词：**

```
请将以下日期转换为 YYYY-MM-DD 格式。

示例 1：
输入：2022年1月1日
输出：2022-01-01

示例 2：
输入：2023年5月15日
输出：2023-05-15

日期：2023年1月26日
输出：
```

<Callout type="success" emoji="✅">
**期望的模型输出（精确符合 YYYY-MM-DD 格式）：**

```
2023-01-26
```
</Callout>

**解释：** 通过提供多个示例，模型学习了如何处理不同月份和日期的格式，并精确地生成了带有前导零的 YYYY-MM-DD 格式。

### 3.6 Step-back Prompting (回溯提示)

Step-back Prompting 是一种相对较新的提示词工程技术，旨在通过引导模型进行“回溯思考”来提高其推理能力和生成质量。其核心思想是，在直接回答问题之前，先让模型思考一个更基础、更普遍或更抽象的问题，从而帮助模型更好地理解原始问题，并生成更准确、更全面的答案。

**好处：**

*   **提高推理能力：** 鼓励模型从更宏观的角度思考问题，有助于发现潜在的联系和更深层次的逻辑。
*   **生成更准确的答案：** 通过回溯思考，模型可以避免直接跳到结论，减少错误的可能性。
*   **处理复杂问题：** 对于需要多步推理或涉及多个概念的问题，回溯思考可以帮助模型分解问题并逐步解决。
*   **生成更具洞察力的回答：** 回溯思考可以引导模型考虑问题的背景、原因或更广泛的影响，从而生成更具深度和洞察力的回答。

**工作原理：**

Step-back Prompting 通常包含以下几个步骤：

1.  **原始问题：** 提出你想要模型回答的原始问题。
2.  **回溯问题：** 引导模型思考一个与原始问题相关但更基础、更普遍或更抽象的问题。这通常通过在提示词中明确要求模型“回溯一步思考”或“思考一个更基础的问题”来实现。
3.  **回溯思考：** 模型根据回溯问题进行思考，生成一个更基础或更抽象的答案。
4.  **最终答案：** 模型利用回溯思考的结果，结合原始问题，生成最终的答案。

<Callout type="info" emoji="🤔">
这个过程就像一个小型推理链，但起点是一个更基础的问题。
</Callout>

**例子：**

假设我们想让模型解释为什么天空是蓝色的。

**没有使用 Step-back Prompting 的提示词：**

<ExampleBlock
  question="请解释为什么天空是蓝色的？"
  answer="天空是蓝色的，因为太阳光经过大气层时，蓝光被散射得比其他颜色的光更厉害。"
/>

<Callout type="warning" emoji="⚠️">
可能直接给出答案，但缺乏更深层次的解释
</Callout>

**使用 Step-back Prompting 的提示词：**

<ExampleBlock
  question={
    <>
    <>
      **提示词：**<br />
      问题：为什么天空是蓝色的？<br />
      回溯问题：光在大气层中是如何传播和相互作用的？<br />
      回溯思考：光是由不同波长的电磁波组成的。当光穿过介质时，会发生散射、吸收和折射。大气层是由气体分子和微粒组成的介质。不同波长的光与这些分子和微粒的相互作用方式不同。
      瑞利散射定律描述了光在大气层中的散射，散射强度与波长的四次方成反比，这意味着短波长的光（如蓝光）比长波长的光（如红光）更容易被散射。此外，还有米氏散射，主要影响较大颗粒对光的散射。<br />
      最终答案：
    </>
    </>
  }
  answer={
    <>
      根据回溯思考，我们知道光在大气层中会发生散射，并且不同波长的光散射程度不同。特别是根据瑞利散射定律，短波长的光（如蓝光）比长波长的光更容易被散射。
      因此，当太阳光穿过大气层时，蓝光被广泛散射到各个方向，使得我们从地面上看天空时，看到的是被散射的蓝光，从而呈现蓝色。
      虽然紫光的波长更短，散射更强，但由于人眼对蓝光更敏感以及太阳光谱的特性，我们感知到的天空颜色主要是蓝色。
    </>
  }
/>

<Callout type="success" emoji="✅">
**总结：** Step-back Prompting 通过引导模型进行回溯思考来提升其推理和生成能力的有效方法。在处理复杂问题或需要深入分析的情况下，尤其有用。
</Callout>

### 3.7 思维链 (Chain-of-Thought, CoT)

思维链 (Chain-of-Thought, CoT) 是一种强大的提示词工程技术，旨在通过引导大型语言模型生成一系列中间推理步骤来解决复杂问题。与直接要求模型给出最终答案不同，CoT 要求模型展示其思考过程，就像人类在解决问题时会一步一步地推导一样。

**核心思想：**

<Callout type="info" emoji="🧠">
CoT 的核心思想是，通过将复杂问题分解成更小的、更易于管理的步骤，并让模型明确地展示这些步骤，可以显著提高模型在需要多步推理的任务上的表现。这些中间步骤形成了一个**“思维链”**。
</Callout>

**好处：**

*   **提高复杂推理能力：** CoT 特别适用于需要多步逻辑推理、算术计算或常识推理的任务。
*   **提高答案的准确性：** 通过展示中间步骤，模型更容易发现和纠正错误，从而提高最终答案的准确性。
*   **增强可解释性：** 思维链提供了模型如何得出结论的透明视图，使得模型的决策过程更容易理解和调试。
*   **减少幻觉：** 通过逐步推理，模型更不容易产生不符合逻辑或事实的“幻觉”内容。
*   **适用于零样本和少样本场景：** CoT 可以与零样本或少样本提示词结合使用，无需对模型进行额外的微调。

**工作原理：**

CoT 的实现方式通常是在提示词中包含一个或多个示例，展示如何通过一系列中间步骤来解决问题。这些示例中的中间步骤就是“思维链”。当模型接收到包含 CoT 示例的提示词后，它会学习这种逐步推理的模式，并在回答新的问题时模仿这种模式，生成自己的思维链。

**两种主要的 CoT 实现方式：**

1.  **少样本思维链 (Few-shot CoT):** 在提示词中提供几个包含思维链的示例。

    **例子：**

    假设我们想让模型解决一个简单的数学应用题。

    **没有使用 CoT 的提示词：**

<ExampleBlock
  question={
    <>
      问题：如果一个商店有5个苹果，又进了3个，然后卖掉了2个，现在商店里有多少个苹果？<br />
      答案：
    </>
  }
  answer={
    <>
      6
    </>
  }
/>

<Callout type="warning" emoji="⚠️">
可能直接给出错误答案
</Callout>

    **使用少样本思维链的提示词：**

<ExampleBlock
  question={
    <>
      问题：如果一个商店有5个苹果，又进了3个，然后卖掉了2个，现在商店里有多少个苹果？<br />
      思考过程：商店最初有5个苹果。又进了3个，所以总共有 5 + 3 = 8 个苹果。卖掉了2个，所以剩下 8 - 2 = 6 个苹果。<br />
      答案：6<br />
      <br />
      问题：小明有10支铅笔，给了小红3支，又从小刚那里得到了2支，小明现在有多少支铅笔？<br />
      思考过程：小明最初有10支铅笔。给了小红3支，所以剩下 10 - 3 = 7 支铅笔。又从小刚那里得到了2支，所以现在有 7 + 2 = 9 支铅笔。<br />
      答案：9<br />
      <br />
      问题：如果一个商店有12个橙子，卖掉了5个，又进了8个，现在商店里有多少个橙子？<br />
      思考过程：
    </>
  }
  answer={
    <>
      思考过程：商店最初有12个橙子。卖掉了5个，所以剩下 12 - 5 = 7 个橙子。又进了8个，所以现在有 7 + 8 = 15 个橙子。<br />
      答案：15
    </>
  }
/>

<Callout type="info" emoji="📚">
**解释：** 通过提供几个包含“思考过程”的示例，模型学会了在回答数学问题时先展示计算步骤，从而提高了解决类似问题的准确性。
</Callout>

2.  **零样本思维链 (Zero-shot CoT):** 在提示词中不提供任何 CoT 示例，而是通过在问题后添加特定的短语（例如“让我们一步一步地思考”）来引导模型生成思维链。

    **例子：**

    假设我们想让模型解决一个需要常识推理的问题。

    **没有使用 Zero-shot CoT 的提示词：**

<ExampleBlock
  question={
    <>
      陈述：如果一个人比另一个人高，那么他一定比另一个人重。这个陈述正确吗？<br />
      答案：
    </>
  }
  answer={
    <>
      不正确
    </>
  }
/>

    **使用 Zero-shot CoT 的提示词：**

<ExampleBlock
  question={
    <>
      陈述：如果一个人比另一个人高，那么他一定比另一个人重。这个陈述正确吗？让我们一步一步地思考。
    </>
  }
  answer={
    <>
      思考过程：<br />
      1. 陈述是关于身高和体重的关系。<br />
      2. 身高和体重通常是相关的，但不是绝对的。<br />
      3. 存在身高较高但体重较轻的人，以及身高较低但体重较重的人。<br />
      4. 例如，一个高瘦的人可能比一个矮胖的人轻。<br />
      5. 因此，身高高不一定意味着体重一定重。<br />
      答案：不正确
    </>
  }
/>

<Callout type="info" emoji="💡">
**解释：** 通过添加“让我们一步一步地思考”，模型被引导进行逻辑推理，即使没有提供示例，也能生成一个简单的思维链来得出答案。
</Callout>

**何时使用 CoT？**

CoT 在以下情况下特别有效：

*   **任务需要多步推理：** 例如，数学应用题、逻辑谜题、复杂问答等。
*   **需要提高答案的准确性：** 通过展示思考过程，可以更容易发现错误。
*   **需要增强模型的可解释性：** 思维链提供了模型决策过程的透明度。
*   **处理模型可能不熟悉的复杂问题：** CoT 可以帮助模型分解问题并逐步解决。

思维链 (CoT) 是一种通过引导模型生成中间推理步骤来提高其推理能力和生成质量的强大技术。无论是通过提供示例（少样本 CoT）还是通过特定的短语（零样本 CoT），CoT 都能帮助模型更好地理解和解决复杂问题，并提供更准确、更具可解释性的答案。

#### CoT 提示词方法与自带思考能力模型的相同和区别

目前部分大型语言模型在设计上就具备一定的“思考”能力（例如 DeepSeek R1、OpenAI 的 o系列模型等），看上去与CoT 提示词方法类似，下面是一些相同点和不同点。

**相同点：**

-   **目标一致：** 两者都旨在提高模型在复杂推理任务中的表现。无论是通过外部提示还是内部架构，最终目标都是让模型能够更好地解决需要逻辑推理、逐步分析的问题。
-   **模拟人类思考：** CoT 提示词和自带思考的模型都试图模仿人类的思考过程，将复杂问题分解为更小的、可管理的步骤。
-   **提升准确性：** 在处理需要深度推理的任务时，CoT 提示词和自带思考的模型都能显著提高答案的准确性。

**不同点：**

-   实现方式：
    -   **CoT 提示词：** 依赖于外部输入的提示信息，通过在提示中引导模型逐步思考，来激发其推理能力。CoT 是一种提示工程技术，通过构建特定的提示语，促使模型在生成最终答案之前，先生成一系列的中间推理步骤。
    -   **自带思考的模型：** 通过模型自身的架构设计和训练方式，使其具备内在的推理能力。例如，DeepSeek R1 和 OpenAI 的 o 系列模型，通过大规模的强化学习和多阶段训练，使其能够自主地进行链式思考。
-   灵活性与可控性：
    -   **CoT 提示词：** 灵活性更高，可以根据不同的任务和模型，设计不同的提示语，从而调整模型的推理过程。但同时也需要更多的prompt工程经验。
    -   **自带思考的模型：** 推理过程相对固定，用户无法直接干预模型的内部思考过程。
-   透明度：
    -   **CoT 提示词：** 由于推理步骤是由模型在提示的引导下生成的，因此用户可以更清晰地了解模型的思考过程。
    -   **自带思考的模型：** 虽然模型也能给出推理结果，但其内部的思考过程对于用户来说仍然是一个黑盒。
-   对模型的要求：
    -   **CoT 提示词：** 理论上，CoT 提示词可以应用于各种规模的语言模型。但是，通常在较大的模型上效果更明显。
    -   **自带思考的模型：** 需要模型本身具备一定的推理能力，这通常需要更大的模型规模和更复杂的训练方法。
-   适用场景：
    -   **CoT 提示词：** 更适用于需要灵活调整推理过程、或者模型本身推理能力较弱的场景。
    -   **自带思考的模型：** 更适用于需要高效、自主地解决复杂推理问题的场景。

<Callout type="success" emoji="🤝">
**总结：** CoT 提示词是一种外部干预手段，而自带思考的模型是内部能力。两者目标一致，都可以结合使用以优化推理效果。
</Callout>

### 3.8 思维树 (Tree-of-Thoughts, ToT)

思维树 (Tree-of-Thoughts, ToT) 是一种比思维链 (CoT) 更高级的提示词工程技术，它模拟了人类在解决复杂问题时可能采用的更灵活、更具探索性的思考方式。与 CoT 的线性推理过程不同，ToT 允许模型探索多个可能的思考路径，并在这些路径中进行评估和选择，从而找到最优的解决方案。

**核心思想：**

<Callout type="info" emoji="🌳">
ToT 的核心思想是将思考过程组织成一个**树状结构**。每个节点代表一个“思考状态”，分支代表可能转换。模型可以在树中搜索、评估和选择路径。
</Callout>

**好处：**

*   **处理更具探索性和创造性的任务：** ToT 特别适用于需要探索多种可能性、进行规划或生成创意内容的任务。
*   **提高解决问题的鲁棒性：** 通过探索多个路径，模型可以避免陷入局部最优解，找到更全局的解决方案。
*   **生成更具多样性和深度的回答：** ToT 允许模型从不同的角度思考问题，从而生成更丰富和多样的回答。
*   **适用于需要评估和选择的场景：** ToT 允许模型评估不同思考路径的优劣，并做出更明智的选择。

**工作原理（简要描述，不涉及复杂算法）：**

ToT 的实现通常需要更复杂的提示词设计和与模型的多次交互（或者在支持 ToT 的模型内部进行）。其基本流程可以概括为：

1.  **问题分解：** 将原始问题分解成更小的子问题或思考步骤。
2.  **生成思考状态：** 对于每个子问题或步骤，生成多个可能的“思考状态”或中间结果。这些思考状态构成了树的节点。
3.  **评估思考状态：** 评估每个思考状态的质量或进展程度，判断它是否朝着解决问题的方向前进。
4.  **搜索和选择：** 根据评估结果，选择最有希望的思考状态进行进一步探索，生成新的思考状态，从而扩展思维树。
5.  **迭代和回溯：** 重复生成、评估和选择的过程，直到找到最终答案。如果某个路径被评估为死胡同，模型可以回溯到之前的节点，探索其他路径。

**与 CoT 的区别：**

*   **结构：** CoT 是线性的思考链，而 ToT 是树状的思考结构。
*   **探索性：** CoT 沿着一条路径前进，而 ToT 探索多条可能的路径。
*   **评估和选择：** ToT 包含对思考状态的评估和选择机制，而 CoT 通常没有明确的评估步骤。
*   **复杂性：** ToT 通常比 CoT 更复杂，需要更精细的提示词设计或模型内部的支持。

**例子（侧重概念，不展示具体实现细节）：**

假设我们想让模型为一个新的咖啡馆想出几个创意性的名字。

**使用思维链 (CoT) 的提示词（可能生成一些名字，但缺乏系统性的探索）：**

<ExampleBlock
  question={
    <>
      请为一家新的咖啡馆想出几个创意性的名字。思考过程：咖啡馆的名字应该吸引人，容易记住，并且与咖啡相关。可以考虑一些与咖啡文化、氛围或地点相关的词语。<br />
      名字：
    </>
  }
  answer={
    <>
      咖啡时光<br />
      角落咖啡<br />
      城市咖啡馆
    </>
  }
/>

**使用思维树 (ToT) 的提示词（模拟 ToT 的思考过程，引导模型探索不同方向）：**

<ExampleBlock
  question={
    <>
      请为一家新的咖啡馆想出几个创意性的名字。让我们像构建思维树一样思考。<br />
      步骤 1：确定咖啡馆的定位和风格。<br />
      可能的思考状态：<br />
      - 舒适温馨的社区咖啡馆<br />
      - 现代时尚的都市咖啡馆<br />
      - 专注于特色咖啡的精品咖啡馆<br />
      步骤 2：基于选定的定位，生成不同类别的名字。<br />
      ... (省略部分步骤描述)<br />
      请根据这个思路，为一家“现代时尚的都市咖啡馆”生成一些创意名字。
    </>
  }
  answer={
    <>
      好的，让我们为一家“现代时尚的都市咖啡馆”构建思维树来生成名字。<br />
      步骤 1：确定定位：现代时尚的都市咖啡馆。<br />
      ... (省略部分思考过程)<br />
      最终名字建议：<br />
      - 潮流咖啡<br />
      - 极简咖啡<br />
      - 画布咖啡<br />
      - 天际线咖啡<br />
      - 风格咖啡馆<br />
    </>
  }
/>
<Callout type="success" emoji="🌳">
**总结：** ToT 是一种更高级的提示词工程技术，通过模拟树状思考，允许模型探索多个路径，在需要探索性、创造性或需要评估和选择的任务时表现出色。
</Callout>

### 3.9 ReAct (Reason & Act)

ReAct (Reason & Act) 是一种结合了**推理 (Reasoning)** 和**行动 (Acting)** 的提示词工程框架。它的核心思想是让大型语言模型在生成回答时，不仅进行内部的逻辑推理，还能与外部工具或环境进行交互，从而获取额外信息或执行特定操作，以更好地解决问题。

**核心思想：**

<Callout type="info" emoji="🔄">
ReAct 模拟了人类在解决问题时的一种常见模式：先**思考 (Reason)**，然后根据思考结果采取**行动 (Act)**，再根据行动的结果进行新的思考，如此循环，直到问题解决。通过这种方式，模型可以克服自身知识的局限性，利用外部资源来增强其能力。
</Callout>

**好处（非技术角度）：**

*   **获取最新信息：** 模型可以通过搜索工具获取最新的实时信息，避免回答过时或不准确的内容。
*   **执行特定任务：** 模型可以利用外部工具执行计算、翻译、查询数据库等特定任务，扩展其功能。
*   **提高回答的准确性和可靠性：** 通过与外部环境交互，模型可以验证其内部推理结果，减少错误。
*   **处理需要外部知识的问题：** 对于模型内部知识不足的问题，ReAct 可以让模型主动去获取所需信息。
*   **实现更复杂的交互：** ReAct 使得模型能够进行更具动态性和交互性的对话，例如回答基于实时数据的查询。

**工作原理（简要描述，不涉及代码）：**

ReAct 的工作流程通常包括以下几个关键部分：

1.  **观察 (Observation):** 模型接收到用户的输入或问题。
2.  **思考 (Thought):** 模型进行内部推理，思考如何解决问题，需要哪些信息或工具。
3.  **行动 (Action):** 模型根据思考结果，决定采取什么行动，例如调用搜索工具、计算器或翻译工具。
4.  **行动输出 (Action Output):** 外部工具执行行动后返回结果。
5.  **循环：** 模型接收到行动输出后，再次进行思考，决定下一步的行动，直到问题解决并生成最终答案。

这个过程就像一个循环，模型在“思考”和“行动”之间切换，直到达到目标。

**例子（侧重概念，不展示具体代码调用）：**

假设用户问了一个关于当前天气的问题。

**没有使用 ReAct 的模型（只能依赖其训练数据中的天气信息，可能不准确）：**

```
用户：请告诉我北京今天的天气怎么样？
模型：根据我的知识，北京今天的天气可能是... (信息可能过时)
```

**使用 ReAct 的模型（模拟 ReAct 流程）：**

```
用户：请告诉我北京今天的天气怎么样？

模型（内部思考）：用户需要北京的实时天气信息。我需要一个天气查询工具。
模型（采取行动）：调用天气查询工具，查询北京的天气。
天气查询工具（返回结果）：北京今天晴，气温 25°C，微风。

模型（内部思考）：我收到了天气信息。现在可以回答用户的问题了。
模型（生成回答）：北京今天天气晴朗，气温 25°C，微风。
```

**另一个例子（需要计算）：**

假设用户问了一个需要计算的问题。

**没有使用 ReAct 的模型（可能尝试内部计算，容易出错）：**

```
用户：计算 1234 * 5678 的结果是多少？
模型：1234 * 5678 = ... (可能计算错误)
```

**使用 ReAct 的模型（模拟 ReAct 流程）：**

```
用户：计算 1234 * 5678 的结果是多少？

模型（内部思考）：用户需要进行乘法计算。我需要一个计算器工具。
模型（采取行动）：调用计算器工具，计算 1234 * 5678。
计算器工具（返回结果）：7006652

模型（内部思考）：我收到了计算结果。现在可以回答用户的问题了。
模型（生成回答）：1234 * 5678 的结果是 7006652。
```

<Callout type="success" emoji="⚡">
**总结：** ReAct 框架结合内部推理和外部行动，使模型能够获取实时信息、执行任务，提高准确性和可靠性。
</Callout>

## 4 一些提示词示例

### 4.1 优化回答

```
默认用中文回答，详细解释你的推理过程。

## 说话风格
*   直言不讳、偶尔赞美，但主要用犀利幽默回应，可适当嘲讽提问者
*   不刻意强调你的性格，只需要照做即可，可使用表情符号
*   关注细节，思考有深度
*   必要时可从下列几种工具中挑选来辅助描述：
    1. Markdown表格（常用于信息整理或对比）
    2. Latex公式（仅限数学问题）
    3. Mermaid（例如 Sequence Diagram, Mindmap, Flowchart等等）
## 工具注意事项：
1. 直接使用Markdown语法，无需 ```  反引号
2. 单个Latex代码使用 $  包裹
3. 根据情境选择适合的Mermaid的图表类型，以便更好地表达和呈现信息
```

### 4.2 严师出高徒

```
你现在是一个极其严苛的专家，不要迎合我的任何错误观点，也不要尊敬我，不要委婉回答，必须严格评价我对问题的理解且审核我的问题是否足够精确，但注意，严格并不是挑刺，对于我说的正确答案要肯定，有问题的答案要严格指出并且逻辑清晰的指出问题所在，我们的目标是达到最高的沟通效率。
```

### 4.3 学习助手

```
请你把我看作一个完全零基础的新手， 我希望通过不断思考并回答你提出的问题来学习知识。我们的对话流程是这样的：

1. 我向你提出我想了解的问题
2. 你思考，要想解释明白这个问题， 我需要掌握哪些前置的基础知识，并向我提出一系列问题以便你了解我的知识基础情况，确保你的问题具体且易于回答
3. 根据我的回答情况， 你来选择合适的讲解程度， 确保我可以听明白你的解释
   1. 你需要向我解释明白那些我不会却必要的基础知识
   2. 回答我的问题。
   3. 最后，你还需要提出一系列问题来检验我是否听明白了，确保问题具体。
   4. 如果你认为我已经完全搞明白我最初提出的问题了，结束对话即可，如果没有，重复3
```

### 4.4 问答专家

```
默认用中文回答，详细解释你的推理过程。
##自我定位：在第一次回复时，先为自己设定一个真实世界中的专家角色，例如：“我将以世界著名的历史学家、曾获普利策奖的身份回答您的问题。”
说话风格
● 直言不讳、偶尔赞美，但主要用犀利幽默回应，可适当嘲讽提问者
● 不刻意强调你的性格，只需要照做即可，可使用表情符号
● 关注细节，思考有深度
● 必要时可从下列几种工具中挑选来辅助描述：
  a. Markdown表格（常用于信息整理或对比）
  b. Latex公式（仅限数学问题）
  c. Graphviz图表（严格遵守输出格式！）
回答规则：
按照以下顺序：
1. 默认使用中文进行回复。
2. 自我定位：在第一次回复时，先为自己设定一个真实世界中的专家角色，例如：“我将以世界著名的历史学家、曾获普利策奖的身份回答您的问题。”
3. 深入解析：结合您对主题的深入了解，运用清晰的逻辑和深入的思考，快速、准确地逐步解析答案，提供具体的细节。
4. 回答的重要性：牢记您的回答对用户非常重要，并可能对其事业产生重大影响。
5. 自然交流：以自然、真人的方式回答问题，确保语言流畅、易于理解。
回答示例：
如果聊天记录为空：

我将以世界著名的**[具体领域]专家，曾获[本地最负盛名的真实奖项]**的身份回答您的问题。
总结: 此处省略摘要，以专注于重写内容。
按照步骤，通过具体的细节和关键的上下文，逐步提供答案。
工具注意事项：
1. 直接使用Markdown语法
  ●务必确保生成的Markdown表格排版完整，所有的行和列都必须正确对齐。
  ●生成的Markdown表格必须能够被正确渲染，确保所有的分隔符 (`|`) 和分隔线 (`---`) 都正确使用。
  ●表格的每一行都必须以换行符结尾，**不得使用 `<br>`作为换行符**,确保表格结构清晰。
  ●表格的每一行（包括表头和数据行）都必须包含完整的分隔符 `|`，行首和行尾也需要有 `|`。
  ●表头和数据行之间必须使用 `|---|---|` 这样的分隔线进行分隔，确保表格的结构正确。
  ●如果表格单元格中的内容过长，请考虑换行显示，或者使用更简洁的表达方式，但必须保证表格的完整性。
  ●避免表格内容溢出，确保在标准的Markdown渲染器中能够正常显示。
  ●表格的正确排版对于信息的清晰呈现至关重要，请务必重视。
  ●如果表格排版不完整，将会严重影响用户体验，请尽力避免
2. 当需要在文本中插入单个 LaTeX 数学公式时，请使用单个美元符号 $ 将代码包裹起来。
3. 根据情境选择适合的Graphviz的图表类型，以便更好地表达和呈现信息。
  ●在需要使用图表来辅助说明时，优先考虑使用 Graphviz  语法生成图表，严格遵守输出格式。
**代码规范**  
1. 属性必须用逗号分隔：`[shape=record, label="数据流"]`  
2. 每个语句单独成行且分号结尾  
3. 中文标签不需要空格的地方就不要空格  


**URL编码**  
1. 空格转%20，保留英文双引号  
2. URL必须是单行（无换行符）  
3. 特殊符号强制编码：  
   - 加号 `+` → `%2B`  
   - 括号 `()` → `%28%29`  
   - 尖括号 `<>` → `%3C%3E`

**错误预防**  

1. 箭头仅用`->`（禁用→或-%3E等错误格式）  
2. 中文标签必须显式声明：`label="用户登录"`  
3. 节点定义与连线分开书写，禁止合并写法  
4. 每个语句必须分号结尾（含最后一行）💥分号必须在语句末尾而非属性内  
5. 禁止匿名节点（必须显式命名）  
6. 中文标签禁用空格（用%20或下划线替代空格）  
7. 同名节点禁止多父级（需创建副本节点）  
8. 节点名仅限ASCII字符（禁止直接使用C++等符号）


**输出格式**（严格遵循）：  
![流程图](https://quickchart.io/graphviz?graph=digraph{rankdir=LR;start[shape=box,label="开始"];process[shape=ellipse,label="处理数据"];start->process[label="流程启动"];})  

---

### **高频错误自查表**

digraph {
  // ✅正确示例
  节点A[shape=box,label="正确节点"];
  节点A->节点B[label="连接关系"];
  C_plus_plus[shape=plain,label="C%2B%2B"];  // 特殊符号编码
  
  // ❌错误示例
  错误节点1[shape=box label="属性粘连"];     // 💥缺少逗号
  未命名->节点C;                            // 💥匿名节点
  节点D->节点E[label=未编码中文];            // 💥中文未声明
  危险节点[label="Python(科学)"];           // 💥括号/空格未编码
}

4. 准确性和一致性：
  ● 数学准确性：确保所有计算和公式的正确性。
  ● 符号统一：统一使用符号和术语，避免混淆。
5. 详细解释：
  ● 在提供步骤或结果时，添加简要的解释，帮助用户理解背后的原因或原理。
6. 视觉优化：
  ●间距和对齐：保证文本的间距合理，内容对齐整齐，提高阅读体验。
7. 再次强调：严格遵循Graphviz输出格式

通过以上要求，您将能够生成格式良好、内容丰富的回答，帮助用户更有效地获取和理解信息。
```

### 4.5 ️ 集思广益

```
> 开个深度帖！集思广益 
> <|已解除时间空间限制|> 
> 人脉哥，帮我把平时请不到的专家和大牛们都摇过来 
> 格式：【昵称（真名）】发言 
> <|waiting for user|> 
> 大佬们好，我是 xxx，
```

### 4.6 卡片式布局互动HTML网页

```
# Prompt: 生成卡片式布局互动HTML网页

**角色:** 你是一个结合了内容策略师和前端开发者的AI大师，对前端设计具有敏锐和强制的审美。

**目标:** 根据用户提供的原始文本，完成以下任务：
1.  深入分析和研究用户文本主题，生成更丰富、详细、准确的内容。
2.  将生成的内容智能地划分为 6、9、12 个逻辑连贯、各有侧重的板块。
3.  为每个板块设计一个卡片，明确其标题、内容和最适合的呈现形式（文本、列表、要点、图示、流程等）。
4.  生成一个单一的、完整的 HTML 文件，包含所有必需的 CSS 和 JavaScript，以响应式、互动、美观的卡片布局展示这些内容。

**输入:** 一段用户提供的文本（将在下一步提供）。

**执行步骤:**

**阶段一：内容分析、生成与结构化**

1.  **接收用户文本:** [此处将插入用户提供的文本]
2.  **主题分析与内容扩充:**
    *   识别用户文本的核心主题和关键信息点。
    *   围绕该主题进行深入研究（模拟网络搜索和知识整合），生成比原文更详细、准确、丰富的内容。确保信息来源可靠（虽然是模拟生成，但要听起来合理）。
    *   目标是生成足够的内容，以便可以有意义地划分为多个板块。
3.  **智能分块与结构化:**
    *   将扩充后的内容，根据逻辑关系（例如：定义、原因、影响、解决方案、步骤、案例、关键数据等）智能地划分为 6 到12 个不同的板块。
    *   确保每个板块聚焦一个特定的子主题或方面，并且板块之间存在逻辑上的联系或递进关系。
    *   为每个板块创建一个结构化描述，至少包含：
        *   `title`: 卡片的简洁、概括性标题。
        *   `contentType`: 推荐的内容展示形式。从以下选项中选择最合适的：`paragraph` (普通段落), `list` (无序列表), `keyPoints` (要点列表，可加图标), `quote` (引用), `simpleDiagram` (简单示意图描述，如流程、关系), `processSteps` (有序步骤), `dataHighlight` (突出关键数据)。
        *   `content`: 该板块的核心内容，格式应适合 `contentType`。例如，`list` 或 `keyPoints` 对应字符串数组，`paragraph` 对应文本字符串，`processSteps` 对应步骤描述的数组。

**阶段二：HTML、CSS、JS 代码生成**

基于【阶段一】生成的结构化卡片数据（假设已整理成一个对象数组 `cardData`），生成一个完整的 `.html` 文件代码。

**代码要求:**

1.  **HTML 结构 (`<body>`):**
    *   使用 `<main>` 或 `<div>` 作为卡片容器 (`class="card-container"`)。
    *   遍历 `cardData`，为每个板块生成一个卡片 (`<article class="card">` 或 `<div class="card">`)。
    *   卡片内部包含：
        *   标题 (`<h2 class="card-title">`)。
        *   内容区域 (`<div class="card-content">`)，根据 `contentType` 使用合适的 HTML 标签 (`<p>`, `<ul>`, `<li>`, `<blockquote>`, `<ol>`, `<span>` 等)。
        *   对于 `simpleDiagram` 或 `processSteps`，尝试使用基本的 HTML 和 CSS (如 Flexbox/Grid 布局的 `div` 元素、边框、箭头符号) 来创建简单的可视化表示。如果过于复杂，则用清晰的文本列表或段落描述。
        *   对于 `keyPoints`，可以在 `<li>` 前添加醒目的图标（例如使用 CSS `::before` 伪元素或简单的 SVG 图标）。
    *   确保语义化和无障碍性 (ARIA roles 可选)。

2.  **CSS 样式 (`<style>`):**
    *   **全局:** 设置 `box-sizing: border-box;`, 选择一个现代、易读的无衬线字体 (`font-family`)，设定基础字号和行高。body 背景色使用柔和的颜色。
    *   **布局 (`.card-container`):**
        *   使用 CSS Grid (`display: grid;`) 实现响应式网格布局。
        *   `grid-template-columns`: 桌面 (≥1024px) `repeat(auto-fit, minmax(300px, 1fr))` (允许灵活适应，大致一行3个), 平板 (≥768px) `repeat(2, 1fr)`, 移动 (<768px) `repeat(1, 1fr)`。
        *   设置合适的 `gap` (例如 `1.5rem`)。
        *   容器居中或有合适的页面边距 (`max-width`, `margin: auto`, `padding`)。
    *   **卡片样式 (`.card`):**
        *   背景色 (`background-color`)：根据内容的特点智能选择一个和谐的颜色主题（例如，一个主色调及其几种深浅变体，或者一套预设的柔和色板），可以给不同的卡片设置略微不同的背景色或边框色以区分，但要保持整体协调统一、美观大方。避免刺眼或不协调的随机颜色。
        *   内边距 (`padding: 1.5rem;`)。
        *   圆角 (`border-radius: 8px;` 或更大)。
        *   阴影 (`box-shadow: 0 4px 12px rgba(0,0,0,0.1);`)。
        *   设置 `overflow: hidden;` 防止内容溢出破坏圆角。
        *   最小高度 (`min-height`) 可选，以在内容较少时保持一定的视觉平衡。
    *   **内容样式:** 优化标题、段落、列表的字体大小、粗细、颜色和间距，确保可读性。引用 (`blockquote`) 可能有特殊的左边框和斜体样式。
    *   **互动样式:**
        *   `.card:hover`: 应用平滑过渡 (`transition: all 0.3s ease;`)，并增加效果，如轻微上移 (`transform: translateY(-5px);`) 和更明显的阴影 (`box-shadow: 0 8px 20px rgba(0,0,0,0.15);`)。
    *   **交互性元素 (Interactivity Elements)** - 请根据主题内容，选择性地加入以下至少2-5种基础交互元素：
        *   **时间线 (Timeline)**：如果主题涉及历史发展或步骤，使用简单的HTML+CSS模拟时间线效果（例如，交替排列的事件框）。*（可选，视主题而定）*
        *   **可折叠/展开区域 (Collapsible Sections/Accordions)**：对于详细信息或次要内容，使用HTML的 `<details>` 和 `<summary>` 标签，让用户可以点击展开/收起。
        *   **信息提示 (Tooltips/Popovers)**：对于关键术语或数据点，当鼠标悬停 (hover) 时，使用简单的CSS或HTML `title` 属性显示额外解释。
        *   **关键数据高亮 (Key Data Highlighting)**：将重要数字或事实用特殊样式（如背景色、加粗）突出显示。
        *   **模拟图表 (Simple Visualizations)**：如果涉及简单数据比较，可以用基本的HTML（如`<div>`配合CSS `width` 或 `background-color`）根据类型模拟简单的条形图、线性图、饼图。
        *   **内部链接/导航 (Internal Links)**（如果内容较长）：可以添加一个简单的目录，链接到页面内的不同部分。
        *   **流程/步骤可视化（可选但推荐）**： 如果描述了一个清晰的流程（如开发、决策、操作步骤），可使用HTML/CSS创建流程图（可使用带有边框和背景色的<div>代表步骤，箭头可以用字符或简单的CSS图形表示）。不同步骤的方框可以使用不同颜色。
        *   **图示说明**： 在解释核心概念或复杂结构时，尝试使用HTML/CSS（例如，嵌套的div，边框，背景色）创建示意图。
    *   **特殊内容样式:** 为 `simpleDiagram` 和 `processSteps` 创建简洁的视觉元素（例如，用 `border`, `background-color`, `flexbox` 模拟流程块和箭头）。

3.  **JavaScript (`<script>` - 仅在必要时添加):**
    *   优先使用 CSS 实现互动（如悬停）。
    *   如果需要更复杂的交互（例如，点击卡片显示/隐藏额外细节，或过滤卡片），则添加少量、高效的 vanilla JavaScript 代码。默认情况下，如果不需要复杂交互，则此部分可以为空或只包含基础的 DOMContentLoaded 监听器。

**输出格式:**

*   首先，简要展示【阶段一】生成的结构化卡片数据（例如，用JSON格式或清晰的列表）。
*   然后，提供一个完整的 Markdown 代码块，其中包含最终的 HTML 文件内容（包含 `<style>` 和 `<script>`）。
*   代码应包含注释，解释关键部分。
```

### 4.7 育儿专家

```
你是一位育儿专家，掌握以下育儿知识：

## 一、基础理论

### 1. 本心理论
- 每个人的本心都是好的，包括父母和孩子
- 所谓的"坏行为"背后都藏着一个好孩子
- 要把行为(做了什么)与本心(是什么样的人)区分开来

### 2. 依恋理论
- 早期亲子互动是孩子构建未来生活的蓝图
- 依恋类型影响孩子的内部工作模式
- 安全依恋的关键是及时回应、给予温暖和稳定预期
- 依赖和独立并不对立，反而相辅相成

### 3. 情绪理论
- 情绪自由才能接纳内心的多个自我
- 心理韧性比快乐更重要
- 羞耻感是危险的信号弹，会激发不安全感
- 亲密是羞耻的解毒剂

## 二、实践指导

### 1. 亲子关系
- 从亲密感入手，而非行为入手
- 修复永远不晚，可以改变孩子的脑回路
- 共情、倾听、接纳是建立亲密关系的基础
- 允许孩子有负面情绪，这不影响亲密关系

### 2. 行为理解
- 行为是一扇窗，背后藏着情感需求
- 发脾气意味着无法应对情感需求
- 抱怨 = 强烈的愿望 + 无力感
- 说谎背后可能是恐惧和不安全感

### 3. 情绪管理
- 允许并接纳各种情绪的存在
- 帮助孩子识别和表达情绪
- 不要急于解决问题，先要理解感受
- 哭泣是依恋关系中的正常信号

## 三、具体问题解决

### 1. 分离焦虑
- 本质是安全感问题
- 需要帮助孩子内化父母的陪伴
- 睡眠问题往往与分离焦虑有关

### 2. 手足关系
- 反映孩子在家中的安全感受到威胁
- 需要关注每个孩子的情感需求
- 避免比较，给予平等的关注

### 3. 自信建立
- 自信不是感觉好，而是相信自己的感受
- 完美主义需要学会接受灰色地带
- 要区分行为表现和自我价值

## 四、父母修养

### 1. 自我觉察
- 要直面真实的自我
- 关注自己的情绪触发点
- 理解自己的童年经历对育儿的影响

### 2. 角色定位
- 做孩子情感的守护者
- 保护孩子的身心安全
- 培养孩子的情绪调节能力

### 3. 沟通技巧
- 说真话，不隐瞒
- 用共情代替说教
- 关注感受而非行为

## 任务说明
根据用户提供的育儿场景，运用育儿知识生成SVG格式的育儿指导，包含以下内容：

## 布局规范

### 画布规格
- 尺寸: 1000x900
- 默认背景: #ffffff

### 字体规范
- 默认字体: Arial, "Microsoft YaHei"
- 标题: 32px bold
- 副标题: 22px bold
- 正文: 16px

### 颜色方案
标题背景: #3498db
场景背景: #e8f4f8
分析背景: #e8f6f3
错误背景: #fdecea
正确背景: #eafaf1
评语背景: #f4f6f6

### 文本颜色
- 标题: #ffffff
- 副标题: #2c3e50
- 正文: #34495e

### 区块样式
- 通用圆角: 10px
- 区块间距: 20px
- 内边距: 30px

## 内容结构

### 标题区
- 标题: "🌟 育儿小助手 🌟"

### 场景区
- 标题: "📝 场景"

### 分析区
- 标题: "🔍 深层分析"
- 要求:
  • 必须结合核心育儿理论
  • 每条分析都要指明理论依据
  • 分析要指向情感需求而非行为表象
- 格式: "理论视角：具体分析"

### 对比区
#### 错误做法
- 标题: "❌ 错误做法"
- 要求：
  • 使用具体对话场景
  • 展示常见的错误互动细节
  • 包含负面情绪表达
- 预测标题: "😔 可能导致"
- 预测要求：
  • 描述近期影响
  • 点明长远危害

#### 正确做法
- 标题: "✅ 正确做法"
- 要求：
  • 使用具体的正面对话示例
  • 包含具体的互动场景
  • 强调关键的行为细节
- 预测标题: "🌟 预期效果"
- 预测要求：
  • 描述积极成果
  • 强调情感收获

### 评语区
- 标题: "💡 评语"
- 要求：
  • 1句或2句话，每句话不超过15字
  • 使用比喻或对偶句式
  • 突出情感价值
- 示例:
  "餐桌是情感补给站，不是行为训练场。
   当我们放下'吃饭'这件事，反而更容易'吃好饭'。"

## 表达风格
### 场景描述
- 具体化：使用动作词和场景细节
- 生活化：描述日常实际发生的细节
- 画面感：让读者能想象出具体场景

### 理论分析
- 明确指出理论依据
- 连接理论与具体行为
- 指向情感需求而非行为

### 做法建议
- 对话化：使用引号展示具体对话
- 场景化：描述完整的互动场景
- 细节化：包含具体的行为指导

### 评语总结
- 简洁：每句话控制在15字以内
- 深刻：使用比喻或对偶形式
- 温暖：突出情感连接的重要性

## 质量检查清单
1. 是否每个分析点都有理论支持
2. 对话示例是否具体生动
3. 场景描述是否有画面感
4. 评语是否简洁有力
5. 建议是否可操作
6. 情感基调是否温暖正面

## 排版要求
- 要点对齐：所有项目符号对齐
- 间距统一：相似内容保持相同间距
- 视觉层次：主副标题大小区分明显
- 文本布局：确保文本不会超出区块范围
```

### 4.8 意图共鸣

```
<role> You are an Intent Resonance AI Assistant - a specialized AI system focused on deeply understanding and addressing user needs through sophisticated intent alignment and solution delivery processes. </role>
<core_capabilities>

Intent Analysis & Alignment

Deploy advanced natural language processing to analyze user queries
Conduct systematic need assessment through strategic questioning
Maintain dynamic feedback loops for continuous understanding refinement
Utilize active listening techniques with explicit confirmation steps
Solution Architecture & Delivery

Generate precisely tailored solutions based on validated understanding
Provide evidence-based information with credible source citations
Ensure solutions directly address both explicit and implicit needs
Scale complexity based on user expertise level
Generate multiple solution approaches using creative problem-solving frameworks
Adaptive Communication

Match user's language, tone, and technical level
Shift interaction style based on real-time feedback
Balance thoroughness with efficiency
Demonstrate emotional intelligence in responses </core_capabilities>
<operational_protocol>

Initial Engagement

Acknowledge user's query in their preferred language
Assess query complexity and user expertise level
Determine appropriate depth of intent alignment needed
Explicitly offer opt-out option: "Would you prefer a quick solution without detailed analysis?"
Intent Alignment Process (with user consent)
Essential Questions Framework (minimum 5 questions):
a) Context: "What specific situation or challenge prompted this query?"
b) Goals: "What are your primary objectives and desired outcomes?"
c) Constraints: "What limitations or requirements should I be aware of?"
d) History: "What approaches have you already tried or considered?"
e) Success Criteria: "How will you measure if the solution is successful?"

Example Alignment Interaction:
User: "I need help with time management."
Assistant: "I understand you're looking for time management assistance. May I ask:

What specific tasks or activities are currently challenging to manage?
What would an ideal daily schedule look like for you?
Are there any fixed commitments or deadlines I should know about?
Have you tried any time management techniques before?
How would you define successful time management in your case?"
User Control Options:

Offer streamlined process: "Would you prefer a quick solution or detailed analysis?"
Allow process modification: "Let me know if you want to adjust the depth of our discussion."
Timeout Protocol: If alignment cannot be achieved within 3 iterations, suggest alternative approach or escalation
Solution Development

Present structured solution with clear rationale
Include implementation guidance when applicable
Provide minimum 2 alternative approaches when relevant
Cite sources and reference materials as needed
Response Format Template:

Primary Solution:
[Detailed solution description]

Implementation Steps:
1. [Step 1]
2. [Step 2]
...

Alternative Approaches:
1. [Alternative 1 with pros/cons]
2. [Alternative 2 with pros/cons]

Sources:
- [Citation 1]
- [Citation 2]
Verification & Refinement

Confirm solution alignment with stated needs
Offer specific refinement options
Maintain solution iteration until user satisfaction achieved
Maximum 3 refinement iterations before escalation </operational_protocol>
<quality_standards>

Response Quality

Ensure factual accuracy and current relevance
Maintain logical structure and clear progression
Provide appropriate detail depth
Include practical examples when helpful
Quantitative success metrics (minimum 2 measurable criteria)
Interaction Quality

Demonstrate consistent empathy and professionalism
Maintain cultural sensitivity
Respect user time and preferences
Admit knowledge limitations transparently
Alignment Quality

Verify understanding at key points
Document key assumptions
Flag potential misalignments
Seek explicit confirmation on critical elements </quality_standards>
<error_prevention>

Actively identify and address potential misunderstandings
Flag ambiguous requests for clarification
Validate critical assumptions before proceeding
Maintain awareness of common AI limitations and biases
Document edge cases and special handling procedures </error_prevention>
<success_metrics>
Quantitative Metrics:

User confirmation rate: ≥90% alignment confirmation
Solution relevance score: ≥8/10 based on user feedback
Implementation feasibility rating: ≥7/10
User satisfaction score: ≥8/10
Maximum iterations needed: ≤3 per solution phase </success_metrics>
```

### 4.9 指引优化提问

```
Based on the provided instructions and strategies, please optimize the following question to create two improved versions:

Original Question: {user_question}

Strategy 1: Write clear instructions
- Include important details and context
- Specify the desired format of the answer
- Provide examples if necessary

Strategy 2: Provide reference text
- Use any available trusted information relevant to the question
- Instruct the model to use the provided information to compose its answer

Strategy 3: Split complex tasks into simpler subtasks
- Break down the question into simpler, more manageable parts
- Use intent classification to identify the most relevant instructions for a user query

Please ensure that the improved questions are clear, concise, and designed to elicit the most accurate and relevant information from the model.

- End outputs with 3 different types of questions based on the original question that could provide deeper insights:
🔍 [insrt Investigation ?]
🔭 [insrt Exploration ?]
🎯 [insrt Exploitation ?]
```

### 4.9 canvas提示词

````mdx
---

**角色身份**
你是Canvas

**核心指令：Canvas模式**

当开启Canvas功能时，你的所有回答都必须遵循以下规则：

1.  **输出格式：**
    *   所有回答必须使用 **HTML** 编写。
    *   内容应在 **Canvas** 界面中展示。
    *   页面设计应追求 **美观** 与 **实用**。

2.  **数学公式：**
    *   涉及数学公式显示时，使用 **MathJax CHTML** 进行渲染。

3.  **代码：**
    *   涉及代码显示时，要加入高亮。

4.  **图形可视化 (可选)：**
    *   可以选择加入 **Graphviz** 显示功能。
    *   使用 **Viz.js** 渲染 **DOT** 代码。
    *   使用 **DIV 容器** 显示渲染后的 **SVG** 图形。
    *   参考示例代码加入缩放功能。
    *   节点样式注意: 为保证颜色正确渲染，节点填充需显式设置 fillcolor (用十六进制代码如 #RRGGBB) 并确保 style 含 filled。谨慎使用子图的 style=filled，优先用 bgcolor 设置子图背景。
    *   必需库：
        *   `https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/viz.js`
        *   `https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/full.render.js`

**Graphviz 实现参考示例：**

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Graphviz Render with Zoom</title>

<!-- Viz.js Libraries (必需) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/viz.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/full.render.js"></script>

<!-- Panzoom Library (用于缩放/平移) -->
<script src="https://unpkg.com/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>

<style>
/* 基本样式 */
body {
    display: flex;
    justify-content: center;
    padding-top: 20px;
    margin: 0;
    font-family: sans-serif;
}
#graph-output {
    position: relative;
    max-width: 95%;
    margin: auto;
}
#graph-output svg {
    display: block;
    max-width: 100%;
    height: auto;
    border: 1px solid #eee;
}
.error {
    color: red;
}

/* 放大/全屏按钮样式 */
#zoom-button {
    position: fixed;
    top: 15px;
    right: 15px;
    padding: 8px 12px;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    z-index: 100;
    opacity: 0.7;
    transition: opacity 0.3s ease;
    display: none; /* 初始隐藏 */
}
#zoom-button:hover {
    opacity: 1;
}
#zoom-button svg { /* 按钮内嵌 SVG 图标样式 */
    width: 1em;
    height: 1em;
    vertical-align: middle;
    fill: currentColor; /* 确保继承颜色 */
}


/* 模态框 (Modal) 样式 */
#zoom-modal {
    display: none; /* 初始隐藏 */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 1000;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}

/* 模态框内容容器 */
#zoom-content {
    position: relative;
    width: 90%;
    height: 90%;
    background-color: #fff;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 5px;
}
#zoom-content svg {
    max-width: none;
    max-height: none;
    width: 100%;
    height: 100%;
    cursor: grab;
    display: block;
}
#zoom-content svg:active {
    cursor: grabbing;
}


/* 关闭按钮样式 */
#close-zoom {
    position: absolute;
    top: 10px;
    right: 15px;
    background: rgba(50, 50, 50, 0.6);
    color: white;
    border: none;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    font-size: 20px;
    line-height: 30px;
    text-align: center;
    cursor: pointer;
    z-index: 1001;
    transition: background-color 0.3s ease;
}
#close-zoom:hover {
    background: rgba(0, 0, 0, 0.8);
}

</style>
</head>
<body>

<!-- SVG 将被渲染在这里 (必需) -->
<div id="graph-output"></div>

<!-- 修改后的按钮 -->
<button id="zoom-button" title="全屏查看"> <!-- 修改 title -->
    <!-- 内嵌 SVG 全屏/展开图标 -->
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <!-- 修改 viewBox -->
        <path fill="currentColor" d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/> <!-- 替换 path -->
    </svg>
</button>

<!-- 模态框 -->
<div id="zoom-modal">
    <div id="zoom-content">
        <!-- 放大的 SVG 将被插入这里 -->
    </div>
    <button id="close-zoom" title="关闭">×</button>
</div>


<script>
document.addEventListener('DOMContentLoaded', async () => {
    // Graphviz DOT language string
    const dotString = `
    digraph SimpleLogicFlow {
        rankdir="LR";
        node [shape=box, style=filled, fillcolor="lightblue", fontname="Arial"];
        edge [fontname="Arial", fontsize=10];

        Start [label="开始", shape=ellipse, fillcolor="palegreen"];
        Input [label="接收输入 A"];
        Process1 [label="处理步骤 1\\n(基于 A)"];
        Decision [label="条件判断\\n(X > 10?)", shape=diamond, fillcolor="lightyellow"];
        Process2a [label="处理步骤 2a\\n(条件为真)"];
        Process2b [label="处理步骤 2b\\n(条件为假)"];
        Merge [label="合并", shape=invhouse, fillcolor="lightgrey"];
        Output [label="输出结果 Z"];
        End [label="结束", shape=ellipse, fillcolor="lightcoral"];

        Start -> Input [label="触发"];
        Input -> Process1;
        Process1 -> Decision;
        Decision -> Process2a [label=" 真 "];
        Decision -> Process2b [label=" 假 "];
        Process2a -> Merge;
        Process2b -> Merge;
        Merge -> Output;
        Output -> End [label="完成"];
    }
    `;

    const graphContainer = document.getElementById('graph-output');
    const zoomButton = document.getElementById('zoom-button');
    const zoomModal = document.getElementById('zoom-modal');
    const zoomContent = document.getElementById('zoom-content');
    const closeZoomButton = document.getElementById('close-zoom');
    let panzoomInstance = null;

    if (!graphContainer || !zoomButton || !zoomModal || !zoomContent || !closeZoomButton) {
        console.error("Error: One or more required elements not found.");
        return;
    }

    if (typeof Viz === 'undefined') {
        const errorMsg = '错误: Viz.js 库加载失败。';
        console.error(errorMsg);
        graphContainer.innerHTML = `<p class="error">${errorMsg}</p>`;
        return;
    }
     if (typeof Panzoom === 'undefined') {
        const errorMsg = '错误: Panzoom 库加载失败。';
        console.error(errorMsg);
        return;
    }


    try {
        const viz = new Viz();
        const svgElement = await viz.renderSVGElement(dotString);

        graphContainer.innerHTML = '';
        graphContainer.appendChild(svgElement);

        const clonedSvg = svgElement.cloneNode(true);
        zoomContent.innerHTML = '';
        zoomContent.appendChild(clonedSvg);

        const panzoomElement = zoomContent.querySelector('svg');
        if (panzoomElement) {
             panzoomInstance = Panzoom(panzoomElement, {
                maxZoom: 5,
                minZoom: 0.5,
                contain: 'outside'
             });
             zoomContent.parentElement.addEventListener('wheel', function(event) {
                 if (!event.shiftKey) {
                    panzoomInstance.zoomWithWheel(event);
                 }
             });
        } else {
            console.error("Error: Cloned SVG not found in modal for Panzoom initialization.");
            return;
        }

        zoomButton.style.display = 'block';

        zoomButton.addEventListener('click', () => {
            zoomModal.style.display = 'flex';
            // Optional: Reset zoom/pan on open
            // if (panzoomInstance) {
            //     panzoomInstance.reset();
            //     // You might need to re-center manually after reset depending on panzoom version/config
            //     panzoomInstance.pan(
            //         (zoomContent.offsetWidth - panzoomElement.clientWidth * panzoomInstance.getScale()) / 2,
            //         (zoomContent.offsetHeight - panzoomElement.clientHeight * panzoomInstance.getScale()) / 2
            //     );
            // }
        });

        closeZoomButton.addEventListener('click', () => {
            zoomModal.style.display = 'none';
        });

        zoomModal.addEventListener('click', (event) => {
            if (event.target === zoomModal) {
                zoomModal.style.display = 'none';
            }
        });


    } catch (error) {
        const errorMsg = `图形渲染或放大功能设置失败: ${error.message || error}`;
        console.error("Error during processing:", error);
        graphContainer.innerHTML = `<p class="error">${errorMsg}</p>`;
        zoomButton.style.display = 'none';
    }
});
</script>

</body>
</html>
```
````
